{"history":[{"visible":true,"aspectRatio":1,"layerType":"effect","type":"gradient","speed":0.52,"trackMouse":0,"mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;const vec3 uColors[1] = vec3[]( vec3(0.788235, 0.717647, 1.000000) );uniform vec2 uMousePos; uniform vec2 uResolution;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) { return uColors[0]; }void main() { vec2 uv = vTextureCoord; vec2 res = uResolution; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); uv -= pos; uv /= (0.52*2.); uv = rotate(uv, (0.20 - 0.5) * 2. * 3.14159265); vec4 color = vec4(getColor(uv), 1); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false}},{"local":{"id":"c34d868d-9538-4ab5-b79a-ab3872e995d2","canvas":{},"ctx":{}},"visible":true,"locked":false,"aspectRatio":1,"isElement":true,"opacity":1,"displace":0,"trackMouse":0,"mouseMomentum":1.0000000000000002,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"dispersion":0,"axisTilt":0.2,"layerType":"text","justCreated":false,"effects":[],"fill":["#000000"],"highlight":["transparent"],"fontSize":180.0320574428473,"fontCSS":{"src":"https://assets.unicorn.studio/fonts/studio_picks/Thunder%2FThunder-BlackLC.otf","family":"Thunder"},"lineHeight":153.63267957308966,"letterSpacing":0,"fontFamily":"Thunder","fontStyle":"900","fontWeight":"400","textAlign":"center","textContent":"WELCOME","gradientAngle":0,"gradientType":"linear","coords":[[0,0],[513.2611608265192,0],[513.2611608265192,153.63267957308966],[0,153.63267957308966]],"rotation":0,"translateX":18,"translateY":169,"width":513.2611608265192,"height":153.63267957308966,"isSafari":false,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; uniform int uSampleBg;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.20); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00);uv = perspectiveUV(uv) - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color/(color.a + 0.00000001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"local":{"id":"61d8163d-25ac-456b-a723-6d011faa63d5","canvas":{},"ctx":{}},"visible":true,"locked":false,"aspectRatio":1,"isElement":true,"opacity":1,"displace":0,"trackMouse":0,"mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"dispersion":0,"axisTilt":0,"layerType":"text","justCreated":false,"effects":[],"fill":["#000000"],"highlight":["transparent"],"fontSize":23.583038083212813,"fontCSS":{"family":"Overused Grotesk","src":"https://assets.unicorn.studio/fonts/studio_picks/Overused%20Grotesk%2FOverusedGrotesk-Roman.otf"},"lineHeight":24.81633978654483,"letterSpacing":0,"fontFamily":"Overused Grotesk","fontStyle":"regular","fontWeight":"400","textAlign":"center","textContent":"Unicorn.studio is a fast and easy way to make your site stand out with WebGL.","gradientAngle":0,"gradientType":"linear","coords":[[0,0],[426.26116082651924,0],[426.26116082651924,49.63267957308966],[0,49.63267957308966]],"rotation":0,"translateX":67,"translateY":325,"width":426.26116082651924,"height":49.63267957308966,"isSafari":false,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color/(color.a + 0.00000001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"local":{"id":"26b48dce-7cc4-4039-bf4c-f693459c3e54","canvas":{},"ctx":{}},"visible":true,"locked":false,"aspectRatio":1.5470008952551477,"isElement":true,"opacity":1,"displace":0,"trackMouse":0,"mouseMomentum":0.56,"blendMode":"MULTIPLY","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"dispersion":0,"axisTilt":0,"layerType":"shape","borderRadius":0,"coords":[[30,4],[-258,4],[-258,283],[30,283]],"effects":["e67a7c71-c26c-4a23-be67-027ddbd44aa9","fa0dac76-7f7f-475b-81ef-f726f17dcfcb"],"fill":["#F2B25C","#EA3363","#EA94E1","#204FD9"],"gradientAngle":0,"gradientType":"linear","rotation":0,"translateX":457,"translateY":89,"type":"circle","numSides":3,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uMaskTexture; uniform sampler2D uTexture; uniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) { return src * dst; }const float STEPS = 24.0; const float PI = 3.1415926;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.00); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); uv = perspectiveUV(uv) - pos; vec4 maskColor = texture(uMaskTexture, vTextureCoord); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); } vec4 color = texture(uTexture, uv);if (3 > 0) { float originalAlpha = color.a; float blendedAlpha = color.a + background.a * (1.0 - color.a); color.rgb = mix(background.rgb, color.rgb/(originalAlpha + 0.00000001), blendedAlpha); vec3 blendedColor = blend(3, color.rgb, background.rgb); color = mix(background, vec4(blendedColor, originalAlpha), originalAlpha * 1.00); } else { color = mix(background, color/(color.a + 0.00000001), color.a * 1.00); }fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"sdf_shape","speed":0.65,"trackMouseMove":0,"mouseMomentum":0.73,"trackMouse":0.6,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord; uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.141592653; const float PI2 = 6.283185306; const float DISP_STEPS = 12.; const vec3 viewDir = vec3(0,0, -4.25);float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }mat3 rotY(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c); }mat3 rotX(float ang) { float c = cos(ang), s = sin(ang); return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); }mat3 rotZ(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0); }vec3 twistY(vec3 p, float amount) { float c = cos(amount * p.y); float s = sin(amount * p.y); mat2 m = mat2(c, -s, s, c); return vec3(m * p.xz, p.y); }vec3 twistX(vec3 p, float amount) { float c = cos(amount * p.x); float s = sin(amount * p.x); mat2 m = mat2(c, -s, s, c); return vec3(p.x, m * p.yz); }float opExtrusion(vec3 p, float d, float h) { vec2 w = vec2( d, abs(p.z) - h ); return min(max(w.x,w.y),0.0) + length(max(w,0.0)); }float sdBlobbyCross(vec2 pos, float he) { pos = abs(pos); pos = vec2(abs(pos.x - pos.y), 1.0 - pos.x - pos.y) / sqrt(2.0);float p = (he - pos.y - 0.25 / he) / (6.0 * he); float q = pos.x / (he * he * 16.0); float h = q * q - p * p * p;float x;if (h > 0.0) { float r = sqrt(h); x = pow(q + r, 1.0 / 3.0) - pow(abs(q - r), 1.0 / 3.0) * sign(r - q); } else { float r = sqrt(p); x = 2.0 * r * cos(acos(q / (p * r)) / 3.0); } x = min(x, sqrt(2.0) / 2.0);vec2 z = vec2(x, he * (1.0 - 2.0 * x * x)) - pos; return length(z) * sign(z.y); }float roundedCross(vec3 p, float r) { p *= rotY(radians(90.)); p *= rotX(radians(90.)); float d = sdBlobbyCross(p.xy * 0.6, r * (0.1 + 0.4 * 0.95)); return opExtrusion(p, d, 0.25); }float sdStar5(vec2 p, float r, float rf) { const vec2 k1 = vec2(0.809016994375, -0.587785252292); const vec2 k2 = vec2(-k1.x,k1.y); p.x = abs(p.x); p -= 2.0*max(dot(k1,p),0.0)*k1; p -= 2.0*max(dot(k2,p),0.0)*k2; p.x = abs(p.x); p.y -= r; vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1); float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r ); return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y); }vec3 getRepeat(vec3 p) { float spacing = (0.50 + 0.11 * 0.38) * 8.; return p; }vec3 getThreeDRepeat(vec3 p) { float spacing = (0.50 + 0.11 * 0.38) * 8.; return p; }vec3 getAdjustedP(vec3 p) { vec3 adjustedP = p;vec2 twist = vec2(0, 0);adjustedP /= (0.30 + 0.001);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.11 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.60); vec2 axis = vec2(vec3(0.30006935873210044, 0.43962286375601606, 0.5994).x - 1. + mousePos.y/PI, vec3(0.30006935873210044, 0.43962286375601606, 0.5994).y + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02; float timeX = vec3(0, 0.64, 0).x * baseTime; float timeY = vec3(0, 0.64, 0).y * baseTime; float timeZ = vec3(0, 0.64, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI); mat3 rotXMat = rotX(axis.x * PI); mat3 rotZMat = rotZ(vec3(0.30006935873210044, 0.43962286375601606, 0.5994).z * 2.0 * PI);mat3 animateYMat = rotY(timeY); mat3 animateXMat = rotX(timeX); mat3 animateZMat = rotZ(timeZ);mat3 combinedRotation = rotZMat * rotYMat * rotXMat; mat3 combinedAnimation = animateZMat * animateYMat * animateXMat;adjustedP = combinedRotation * adjustedP; adjustedP = combinedAnimation * adjustedP; adjustedP = getThreeDRepeat(adjustedP); adjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y))); adjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP; }float getMergedSDF(vec3 p) { p = getAdjustedP(p); return roundedCross(p, 1.); }float fresnel(vec3 eyeVector, vec3 worldNormal, float power) { float fresnelFactor = abs(dot(eyeVector, worldNormal)); float inversefresnelFactor = 1.0 - fresnelFactor; return pow(inversefresnelFactor, power); }float specular(vec3 viewDir, vec3 lightDir, vec3 normal, float shininess, float diffuseness) { lightDir.xy -= vec2(0.5, 0.497987532880693); vec3 halfVector = normalize(viewDir + lightDir); float NdotL = max(0.0, dot(normal, lightDir)); float NdotH = max(0.0, dot(normal, halfVector));float kSpecular = pow(NdotH, shininess); return kSpecular * diffuseness; }vec3 frostOrDispersion(vec3 rd, vec3 normal) { vec3 refractionColor = vec3(0); float iorBase = 1. + 0.31 * 0.25;vec3 dispCoefficients = vec3(0.03, 0.06, 0.1) * 0.11 * 1.2;for(float i = 0.; i < DISP_STEPS; i++) { float step = i / DISP_STEPS; vec3 disp = step * dispCoefficients; vec3 ior = 1.0 / (iorBase + disp);vec3 refractedRayR = refract(rd, normal, ior.r); vec3 refractedRayG = refract(rd, normal, ior.g); vec3 refractedRayB = refract(rd, normal, ior.b);refractionColor.r += texture(uTexture, vTextureCoord - refractedRayR.xy).r; refractionColor.g += texture(uTexture, vTextureCoord - refractedRayG.xy).g; refractionColor.b += texture(uTexture, vTextureCoord - refractedRayB.xy).b; }return clamp(refractionColor / DISP_STEPS, 0.0, 1.0); }vec3 calculateNormal(vec3 p, float size) {float gradientX = getMergedSDF(p + vec3(size, 0.0, 0.0)) - getMergedSDF(p - vec3(size, 0.0, 0.0)); float gradientY = getMergedSDF(p + vec3(0.0, size, 0.0)) - getMergedSDF(p - vec3(0.0, size, 0.0)); float gradientZ = getMergedSDF(p + vec3(0.0, 0.0, size)) - getMergedSDF(p - vec3(0.0, 0.0, size)); vec3 normal = vec3(gradientX, gradientY, gradientZ); return normalize(normal); }vec3 sampleTexture(vec3 rd, vec3 normal) {return frostOrDispersion(rd, normal); }float scene(vec3 p) { return (getMergedSDF(p) - 0.11) * ((0.30 + 0.001)); }const int STEPS = 128; const float MAX_DISTANCE = 40.0;vec4 rayMarch(vec3 ro, vec3 rd, float min_dist) {float traveled = 0.; vec3 entryPoint = vec3(0.0); vec3 entryNormal = vec3(0.0); float partialAlpha = 0.0; float antialias_dist = min_dist + min_dist * 0.25;for (int i = 0; i < STEPS; ++i) { vec3 currentPos = ro + rd * traveled; float distance = scene(currentPos); if (distance < min_dist) { entryPoint = currentPos; partialAlpha = 1.0; entryNormal = calculateNormal(entryPoint, min_dist); break; } else if(distance < antialias_dist) { partialAlpha = 0.5; entryPoint = currentPos; entryNormal = calculateNormal(entryPoint, distance); }if(traveled < 0.01) { traveled += distance * 0.9; } else { traveled += distance; } if (traveled > MAX_DISTANCE) break; }if (partialAlpha == 0.0) { return texture(uTexture, vTextureCoord); }vec4 bg = texture(uTexture, vTextureCoord);vec3 refractionColor = sampleTexture(rd, entryNormal); float lightAndShadow = entryNormal.g * 0.25 - entryNormal.r * 0.25; vec3 lightColor = mix(vec3(1), vec3(1, 1, 1), 1. - 0.00); vec3 fresnelEffect = fresnel(rd, entryNormal, 8.) * 0.23 * lightColor; vec3 specularEffect = specular(vec3(0.5, 0.5, -3.), normalize(rd - entryPoint), entryNormal, 64.0 * 1.00 + 0.01, 1.00 + 0.01) * lightColor;refractionColor = mix(refractionColor, vec3(1, 1, 1) + lightAndShadow, 0.00); return mix(bg, vec4(refractionColor + fresnelEffect + specularEffect, 1), partialAlpha); }out vec4 fragColor;void main() { vec2 pos = vec2(0.5, 0.497987532880693) + mix(vec2(0), (uMousePos-0.5), 0.00); vec2 uv = vTextureCoord - pos; float fovFactor = tan(radians(20.) * 0.5); vec3 rd = vec3(uv * fovFactor, 0.5);float mdist = 4. / uResolution.y; vec4 col = rayMarch(viewDir, rd, mdist); float dither = (rand(vTextureCoord.xy) - 0.5) / 255.0; col += dither; fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"noise","speed":0.53,"trackMouse":1,"mouseMomentum":1,"texture":false,"parentLayer":"e67a7c71-c26c-4a23-be67-027ddbd44aa9","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { switch(3) { case 0: return t; break; case 1: return t * t; break; case 2: return t * (2.0 - t); break; case 3: return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; break; case 4: return t * t * t; break; case 5: return --t * t * t + 1.0; break; case 6: return t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0; break; case 7: return t * t * t * t; break; case 8: return 1.0 - (--t) * t * t * t; break; case 9: return t < 0.5 ? 8.0 * t * t * t * t : 1.0 - 8.0 * (--t) * t * t * t; break; case 10: return t * t * t * t * t; break; case 11: return 1.0 + (--t) * t * t * t * t; break; case 12: return t < 0.5 ? 16.0 * t * t * t * t * t : 1.0 + 16.0 * (--t) * t * t * t * t; break; case 13: return 1.0 - sqrt(1.0 - t * t); break; case 14: return sqrt((2.0 - t) * t); break; case 15: return t < 0.5 ? (1.0 - sqrt(1.0 - 4.0 * t * t)) / 2.0 : (sqrt(-((2.0 * t) - 3.0) * ((2.0 * t) - 1.0)) + 1.0) / 2.0; break; case 16: return t == 0.0 ? 0.0 : pow(2.0, 10.0 * (t - 1.0)); break; case 17: return t == 1.0 ? 1.0 : 1.0 - pow(2.0, -10.0 * t); break; case 18: return t == 0.0 ? 0.0 : t == 1.0 ? 1.0 : t < 0.5 ? pow(2.0, (20.0 * t) - 10.0) / 2.0 : (2.0 - pow(2.0, -20.0 * t + 10.0)) / 2.0; break; case 19: return 1.0 - cos((t * 3.141592654) / 2.0); break; case 20: return sin((t * 3.141592654) / 2.0); break; case 21: return -(cos(3.141592654 * t) - 1.0) / 2.0; break; case 22: return t == 0.0 ? 0.0 : t == 1.0 ? 1.0 : -pow(2.0, 10.0 * t - 10.0) * sin((t * 10.0 - 10.75) * ((2.0 * 3.141592654) / 3.0)); break; case 23: return t == 0.0 ? 0.0 : t == 1.0 ? 1.0 : pow(2.0, -10.0 * t) * sin((t * 10.0 - 0.75) * ((2.0 * 3.141592654) / 3.0)) + 1.0; break; case 24: return t == 0.0 ? 0.0 : t == 1.0 ? 1.0 : t < 0.5 ? -(pow(2.0, 20.0 * t - 10.0) * sin((20.0 * t - 11.125) * ((2.0 * 3.141592654) / 4.5))) / 2.0 : (pow(2.0, -20.0 * t + 10.0) * sin((20.0 * t - 11.125) * ((2.0 * 3.141592654) / 4.5))) / 2.0 + 1.0; break; } }out vec4 fragColor;void main() { vec2 noise = vTextureCoord; vec2 uv = vVertexPosition.xy; float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 1.00); vec2 pos = vec2(0.5, 0.5); float dist = ease(3, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 0.68)));uv = mix(uv, noise, dist);vec4 color = texture(uTexture, uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float; in vec3 aVertexPosition; in vec2 aTextureCoord; uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec3 vVertexPosition; out vec2 vTextureCoord;uniform float uTime; uniform sampler2D uMaskTexture; uniform vec2 uMousePos; uniform vec2 uResolution;vec4 permute(vec4 t) { return t * (t * 34.0 + 133.0); } vec3 grad(float hash) { vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0; vec3 cuboct = cube; cuboct[int(hash / 16.0)] = 0.0; float type = mod(floor(hash / 8.0), 2.0); vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct)); vec3 grad = cuboct * 1.22474487139 + rhomb; grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184; return grad; } vec4 bccNoiseDerivativesPart(vec3 X) { vec3 b = floor(X); vec4 i4 = vec4(X - b, 2.5); vec3 v1 = b + floor(dot(i4, vec4(.25))); vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35))); vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35))); vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35))); vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0)); hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0)); hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0); vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4; vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0); vec4 aa = a * a; vec4 aaaa = aa * aa; vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y); vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w); vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4)); vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations) + mat4x3(g1, g2, g3, g4) * aaaa; return vec4(derivative, dot(aaaa, extrapolations)); } vec4 bccNoiseDerivatives_XYZ(vec3 X) { X = dot(X, vec3(2.0/3.0)) - X; vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5); return vec4(dot(result.xyz, vec3(2.0/3.0)) - result.xyz, result.w); } vec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) { mat3 orthonormalMap = mat3( 0.788675134594813, -0.211324865405187, -0.577350269189626, -0.211324865405187, 0.788675134594813, -0.577350269189626, 0.577350269189626, 0.577350269189626, 0.577350269189626); X = orthonormalMap * X; vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5); return vec4(result.xyz * orthonormalMap, result.w); }const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } void main() { vec3 vertexPosition = aVertexPosition; vec2 textureCoord = (vertexPosition.xy+1.) / 2.; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 1.00); vec2 st = vec2(textureCoord.x * uResolution.x/uResolution.y, textureCoord.y) - pos; st = rot(0.04 * -1. * 2.0 * PI) * (st); vec4 noise = bccNoiseDerivatives_XYBeforeZ(vec3(st * vec2(0.50, 1. - 0.50) * 9. * 0.58, 0.00 + uTime*0.02)); st.xy = mix(textureCoord, (noise.xy/7. + 0.5), 0.69); gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(st, 0.0, 1.0)).xy; vVertexPosition = vec3(aTextureCoord, 0.); }"],"data":{"depth":false}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"pixelate","trackMouse":0,"mouseMomentum":1,"texture":false,"parentLayer":"fa0dac76-7f7f-475b-81ef-f726f17dcfcb","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor; void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; vec2 pos = vec2(0.14285714285714285, 0.34630582831802337) + mix(vec2(0), (uMousePos-0.5), 0.00); float gridSize = (0.24 + 0.01) / 12.; vec2 modulate = mod(vec2(uv.x * aspectRatio, uv.y) - pos * vec2(aspectRatio, 1), gridSize); vec2 pixelatedCoord = vec2( uv.x - modulate.x / aspectRatio + (0.08333 * 0.24)/2., uv.y - modulate.y + (0.08333 * 0.24)/2. );vec2 cMod = modulate + 0.5 * gridSize - vec2(gridSize)*0.5; float dist = 1. - length(cMod - vec2(0.5 * gridSize, 0.5 * gridSize)) / length(gridSize); vec4 color = texture(uTexture, pixelatedCoord);if(dist < (1.-1.00)) { if(0 == 1) { color.rgb = vec3(0, 0, 0); } else { discard; } }color *= color.a; fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false}}],"options":{"name":"Hero section","fps":60,"dpi":2,"scale":1,"includeLogo":true,"isProduction":false,"version":"1.2.7"},"version":"1.2.7"}